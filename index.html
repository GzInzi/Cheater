<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cheater</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      body {
        background-color: #f0f0f0;
      }
      .iphone-glass-effect {
        background-color: rgba(255, 255, 255, 0.4);
        backdrop-filter: blur(10px) saturate(180%);
        -webkit-backdrop-filter: blur(10px) saturate(180%);
        /* Border will now be applied conditionally with Tailwind */
      }
      .answer-highlight {
        background-color: rgba(59, 130, 246, 0.2); /* blue-500 with transparency */
      }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Main App component
        function App() {
          const [isListening, setIsListening] = useState(false);
          const [recognition, setRecognition] = useState(null);
          const [speechText, setSpeechText] = useState('');
          const [answer, setAnswer] = useState('');
          const [isAiProcessing, setIsAiProcessing] = useState(false);
          const [isSpeaking, setIsSpeaking] = useState(false);
          const [error, setError] = useState('');
          const [isReady, setIsReady] = useState(false);
          const [apiKey, setApiKey] = useState("");
          const [showApiModal, setShowApiModal] = useState(false);
          const [saveApiKey, setSaveApiKey] = useState(false);
          const [statusMessage, setStatusMessage] = useState('');
          const speechTextRef = useRef('');

          // Load API key from localStorage on component mount
          useEffect(() => {
            const savedKey = localStorage.getItem('geminiApiKey');
            if (savedKey) {
              setApiKey(savedKey);
              setSaveApiKey(true);
            }
          }, []);

          // Set up the SpeechRecognition API
          useEffect(() => {
            if ('webkitSpeechRecognition' in window) {
              const newRecognition = new window.webkitSpeechRecognition();
              newRecognition.continuous = true; 
              newRecognition.lang = 'en-US'; 
              newRecognition.interimResults = true; 

              newRecognition.onstart = () => {
                setIsListening(true);
                setError('');
              };

              newRecognition.onresult = (event) => {
                let fullTranscript = '';
                for (let i = 0; i < event.results.length; i++) {
                    fullTranscript += event.results[i][0].transcript;
                }
                setSpeechText(fullTranscript);
              };

              newRecognition.onerror = (event) => {
                setIsListening(false);
                if (event.error === 'not-allowed') {
                  setError("Microphone access was denied. Please enable it.");
                } else {
                  setError(`Speech recognition error: ${event.error}`);
                }
                console.error('Speech recognition error:', event.error);
              };
              
              newRecognition.onend = () => {
                setIsListening(false);
                if (speechTextRef.current.trim()) { 
                    handleAskAI(speechTextRef.current.trim());
                }
              };
              
              setRecognition(newRecognition);
              setIsReady(true);
            } else {
              setError("Speech Recognition is not supported in this browser.");
            }
          }, []);

          useEffect(() => {
            speechTextRef.current = speechText;
          }, [speechText]);

          // Function to start or stop listening
          const toggleListening = () => {
            if (!recognition) {
              setError("Speech Recognition is not available.");
              return;
            }
            if (isListening) {
              recognition.stop();
            } else {
              setSpeechText('');
              setAnswer('');
              setError('');
              recognition.start();
            }
          };
          
          const handleAskAI = async (text) => {
            if (!text) return;
            let keyToUse = apiKey || localStorage.getItem('geminiApiKey');
            
            if (!keyToUse) {
              setShowApiModal(true);
              return;
            }

            setIsAiProcessing(true);
            setAnswer('');
            setError('');
            setStatusMessage('Thinking...');

            const MAX_RETRIES = 3;
            let lastError = null;

            for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
                try {
                    if (attempt > 0) {
                        const waitMs = 1000 * (2 ** (attempt - 1));
                        setStatusMessage(`Model busy. Retrying... (${attempt}/${MAX_RETRIES - 1})`);
                        await new Promise(resolve => setTimeout(resolve, waitMs));
                    }

                    const prompt = `You will be given a multiple-choice question and a list of possible answers. Your task is to choose the single best answer from the provided list ONLY. Do not use outside knowledge to provide an answer that is not in the list. Respond with only the text of the correct option. The user's input is: "${text}"`;
                    
                    const payload = { contents: [{ role: "user", parts: [{ text: prompt }] }] };
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${keyToUse}`;
                    
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.status >= 500 || response.status === 429) {
                        const errorData = await response.json();
                        const errorMessage = errorData.error?.message.includes('overloaded') 
                            ? "The model is overloaded." 
                            : (errorData.error?.message || `Server error: ${response.statusText}`);
                        throw new Error(errorMessage);
                    }

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error?.message || `API error: ${response.statusText}`);
                    }

                    const result = await response.json();
                    if (result.candidates && result.candidates.length > 0) {
                        const generatedText = result.candidates[0].content.parts[0].text;
                        setAnswer(generatedText.trim().replace(/[\*\."]/g, ''));
                    } else {
                        setAnswer("Sorry, I couldn't generate a response.");
                    }

                    setIsAiProcessing(false);
                    setStatusMessage('');
                    return; 

                } catch (error) {
                    lastError = error;
                    console.error(`Attempt ${attempt + 1} failed:`, error.message);
                    if (!error.message.includes("overloaded") && !error.message.includes("Server error")) {
                        break;
                    }
                }
            }

            setAnswer(`Error: ${lastError.message}`);
            if (lastError.message.includes("API key not valid")) {
                setError("Your API key is invalid. Please check it.");
                setShowApiModal(true);
            }
            setIsAiProcessing(false);
            setStatusMessage('');
          };

          const handleSpeakAnswer = (textToSpeak) => {
            if (!textToSpeak || !('speechSynthesis' in window) || textToSpeak.startsWith('Error:')) {
              return;
            }
            if (isSpeaking) {
                window.speechSynthesis.cancel();
                setIsSpeaking(false);
                return;
            }
            setIsSpeaking(true);
            const utterance = new SpeechSynthesisUtterance(textToSpeak);
            utterance.onend = () => setIsSpeaking(false);
            utterance.onerror = (event) => {
              console.error("SpeechSynthesis Error", event);
              setError("An error occurred during speech synthesis.");
              setIsSpeaking(false);
            };
            window.speechSynthesis.speak(utterance);
          };
          
          return (
            // ############  UPDATED LAYOUT CONTAINER  ############
            <div className="min-h-screen bg-gray-200 font-sans text-gray-800 flex sm:items-center sm:justify-center">
              {/* ############  UPDATED CARD WITH RESPONSIVE STYLES  ############ */}
              <div className="iphone-glass-effect w-full flex-grow flex flex-col p-6 space-y-4 text-center sm:flex-grow-0 sm:max-w-sm sm:rounded-3xl sm:shadow-lg sm:border border-gray-300/30">
                
                {/* This div pushes the button and output to the bottom on mobile */}
                <div className="flex-grow flex flex-col justify-center items-center space-y-4">
                    <div className="mb-4">
                      <h1 className="text-3xl font-bold text-gray-800 mb-2">Cheater</h1>
                      <p className="text-gray-600">Tap the mic to start, speak, then tap again to stop.</p>
                    </div>

                    <button
                      onClick={toggleListening}
                      disabled={!isReady || isAiProcessing}
                      className={`w-28 h-28 rounded-full transition-all duration-300 shadow-lg flex-shrink-0
                      ${isListening ? 'bg-red-500 transform scale-110 ring-4 ring-red-300' : 'bg-blue-500 hover:bg-blue-600'} 
                      disabled:bg-gray-400 disabled:scale-100 disabled:ring-0`}
                    >
                      <svg className={`mx-auto text-white ${isListening ? 'animate-pulse' : ''}`} width="48" height="48" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                        <path d="M12 14C13.1046 14 14 13.1046 14 12V6C14 4.89543 13.1046 4 12 4C10.8954 4 10 4.89543 10 6V12C10 13.1046 10.8954 14 12 14Z"/>
                        <path d="M17 12C17 14.7614 14.7614 17 12 17C9.23858 17 7 14.7614 7 12H5C5 15.866 7.93452 19 11.5 19V22H12.5V19C16.0655 19 19 15.866 19 12H17Z"/>
                      </svg>
                    </button>

                    <div className="h-6">
                      {error && <p className="text-red-500">{error}</p>}
                      {isListening && <p className="text-gray-800 animate-pulse">Listening...</p>}
                      {isAiProcessing && !isListening && <p className="text-gray-800 animate-pulse">{statusMessage}</p>}
                    </div>
                </div>

                {/* This is the output section */}
                <div className="space-y-4 flex-shrink-0">
                  <div className="iphone-glass-effect p-4 rounded-xl text-left min-h-[6rem] max-h-48 overflow-auto border border-gray-300/30">
                    <h2 className="text-lg font-bold mb-2 text-gray-800">Your Question:</h2>
                    <p className="text-gray-600">{speechText || <span className="italic text-gray-400">Your question will appear here.</span>}</p>
                  </div>
                  
                  {answer && (
                    <div className={`relative iphone-glass-effect p-4 rounded-xl text-left border border-gray-300/30 ${answer && 'answer-highlight'}`}>
                      <h2 className="text-lg font-bold mb-2 text-gray-800">AI Answer:</h2>
                      <p className="text-gray-600">{answer}</p>
                      {!answer.startsWith('Error:') && (<button
                        onClick={() => handleSpeakAnswer(answer)}
                        disabled={!answer}
                        className="absolute bottom-4 right-4 bg-gray-300 hover:bg-gray-400 disabled:bg-gray-400 text-gray-800 p-2 rounded-full transition duration-200"
                        aria-label="Read answer aloud"
                      >
                        {isSpeaking ? (
                           <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                             <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12" />
                           </svg>
                        ) : (
                          <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
                          </svg>
                        )}
                      </button>)}
                    </div>
                  )}
                </div>
              </div>

              {showApiModal && (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4">
                  <div className="bg-white p-6 rounded-xl shadow-lg w-full max-w-md">
                    <h2 className="text-xl font-bold text-gray-800 mb-4">Enter Gemini API Key</h2>
                    <p className="text-gray-600 mb-4">You need a Gemini API key to use this app. You can get one from Google AI Studio.</p>
                    <input
                      type="password"
                      className="w-full p-2 border border-gray-300 rounded-md mb-4 text-gray-800"
                      placeholder="Enter your API key here..."
                      value={apiKey}
                      onChange={(e) => setApiKey(e.target.value)}
                    />
                    <div className="flex items-center space-x-2 mb-4">
                      <input
                        type="checkbox"
                        id="save-key-checkbox"
                        checked={saveApiKey}
                        onChange={(e) => setSaveApiKey(e.target.checked)}
                        className="h-4 w-4 text-blue-600 border-gray-300 rounded"
                      />
                      <label htmlFor="save-key-checkbox" className="text-gray-600">Save API Key in browser</label>
                    </div>
                    <div className="flex justify-end space-x-2">
                      <button
                        onClick={() => setShowApiModal(false)}
                        className="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-xl transition duration-200"
                      >
                        Cancel
                      </button>
                      <button
                        onClick={() => {
                          if (saveApiKey) {
                            localStorage.setItem('geminiApiKey', apiKey);
                          } else {
                            localStorage.removeItem('geminiApiKey');
                          }
                          setShowApiModal(false);
                          if (speechTextRef.current.trim()) {
                            handleAskAI(speechTextRef.current.trim());
                          }
                        }}
                        disabled={!apiKey}
                        className="bg-blue-500 hover:bg-blue-600 disabled:bg-gray-400 text-white font-bold py-2 px-4 rounded-xl transition duration-200"
                      >
                        Save and Use
                      </button>
                    </div>
                  </div>
                </div>
              )}
            </div>
          );
        }

        // Render the App component into the root element
        const rootElement = document.getElementById('root');
        ReactDOM.render(<App />, rootElement);
    </script>
</body>
</html>
